package com.example.myapp;

import static com.codename1.ui.CN.*;

import java.io.IOException;
import java.io.InputStream;

import com.codename1.system.Lifecycle;
import com.codename1.ui.*;
import com.codename1.ui.layouts.*;
import com.codename1.io.*;
import com.codename1.media.Media;
import com.codename1.media.MediaManager;
import com.codename1.ui.plaf.*;
import com.codename1.ui.util.Resources;
import com.codename1.components.SpanLabel;

import net.informaticalibera.japanesetts.JapaneseTTS;

/**
 * This file was generated by <a href="https://www.codenameone.com/">Codename One</a> for the purpose
 * of building native mobile applications using Java.
 */
public class MyApp extends Lifecycle {
    private Media media = null;
    private InputStream mediaStream = null;
    
    @Override
    public void runApp() {        
        Form f = new Form("Japanese TTS Demo", BoxLayout.y());
        SpanLabel pathLabel = new SpanLabel("");

        SpanLabel status = new SpanLabel("");
        TextArea text = new TextArea(5, 40);
        text.setHint("Type Japanese text here (UTF-8)...");

        Button speak = new Button("Speak");
        Button stop = new Button("Stop");

        // --- Voice controls (rate + pitch) ---
        // Slider works with an integer range; we scale to float.
        // Speech rate: 0.50x .. 2.00x  (OpenJTalk -r)
        Label rateLabel = new Label("Rate: ");
        final Slider rateSlider = new Slider();
        rateSlider.setEditable(true);
        rateSlider.setMinValue(50);
        rateSlider.setMaxValue(200);
        rateSlider.setProgress(Math.round(JapaneseTTS.getSpeechRate() * 100f));
        final Label rateValue = new Label();
        rateValue.setText(formatOneDecimal(JapaneseTTS.getSpeechRate()));
        Component.setSameHeight(rateLabel, rateSlider, rateValue);

        rateSlider.addDataChangedListener((type, index) -> {
            float r = rateSlider.getProgress() / 100f;
            JapaneseTTS.setSpeechRate(r);
            rateValue.setText(formatOneDecimal(r));
            f.revalidate();
        });

        // Pitch: -9.0 .. +9.0 semitones (OpenJTalk -fm)
        // We represent it as 0..240, where 120 == 0.0.
        Label pitchLabel = new Label("Pitch: ");
        final Slider pitchSlider = new Slider();
        pitchSlider.setEditable(true);
        pitchSlider.setMinValue(0);
        pitchSlider.setMaxValue(240);
        pitchSlider.setProgress(120 + Math.round(JapaneseTTS.getPitch() * 10f));
        final Label pitchValue = new Label();
        pitchValue.setText(formatOneDecimal(JapaneseTTS.getPitch()));
        Component.setSameHeight(pitchLabel, pitchSlider, pitchValue);
        Component.setSameWidth(rateLabel, pitchLabel);

        pitchSlider.addDataChangedListener((type, index) -> {
            float p = (pitchSlider.getProgress() - 120) / 10f;
            JapaneseTTS.setPitch(p);
            pitchValue.setText(formatOneDecimal(p));
            f.revalidate();
        });

        Button resetVoice = new Button("Defaults");
        resetVoice.addActionListener(ev -> {
            JapaneseTTS.resetVoiceParams();
            rateSlider.setProgress(Math.round(JapaneseTTS.DEFAULT_SPEECH_RATE * 100f));
            pitchSlider.setProgress(120 + Math.round(JapaneseTTS.DEFAULT_PITCH * 10f));
            rateValue.setText(formatOneDecimal(JapaneseTTS.DEFAULT_SPEECH_RATE));
            pitchValue.setText(formatOneDecimal(JapaneseTTS.DEFAULT_PITCH));
            f.revalidate();
        });

        speak.addActionListener(e -> {
            String t = text.getText();
            if(t == null) t = "";
            t = t.trim();
            if(t.length() == 0) return;

            if(!JapaneseTTS.isSupported()) {
                status.setText("Japanese Offline TTS CN1Lib not supported on this platform");
                return;
            }
            // IMPORTANT: synthesis can take seconds (dictionary extraction + native process). Run off the EDT.
            speak.setEnabled(false);
            status.setText("Synthesizing...");
            f.revalidate();

            final String textToSpeak = t;
            Display.getInstance().scheduleBackgroundTask(() -> {
                String wav = null;
                Throwable err = null;
                try {
                    wav = JapaneseTTS.synthesizeToWav(textToSpeak);
                    if (wav == null || wav.trim().length() == 0) {
                        throw new IOException("No WAV generated");
                    }
                } catch (Throwable t1) {
                    err = t1;
                }

                final String wavFinal = wav;
                final Throwable errFinal = err;
                Display.getInstance().callSerially(() -> {
                    try {
                        if (errFinal != null) {
                            status.setText("Error while starting TTS: " + simpleName(errFinal));
                            Log.e(errFinal);
                            return;
                        }
                        pathLabel.setText("File wav: " + wavFinal);
                        f.revalidate();
                        playWav(wavFinal);
                        status.setText("Ready");
                    } catch (Throwable ex) {
                        Log.e(ex);
                        status.setText("Error while starting TTS: " + simpleName(ex));
                    } finally {
                        speak.setEnabled(true);
                        f.revalidate();
                    }
                });
            });
        });

        stop.addActionListener(e -> {
            if(!JapaneseTTS.isSupported()) {
                status.setText("Japanese Offline TTS CN1Lib not supported on this platform");
                return;
            }
            try {
                stopWav();
            } catch(Throwable ex) {
                status.setText("Error while stopping TTS: " + simpleName(ex));
            }
        });

        if(!JapaneseTTS.isSupported()) {
            status.setText("Japanese Offline TTS CN1Lib not supported on this platform");
            speak.setEnabled(false);
            stop.setEnabled(false);
        } else {
            status.setText("Ready");
        }

        f.addAll(status,
                new Label("Text:"),
                text,
                FlowLayout.encloseCenter(resetVoice),
                FlowLayout.encloseCenter(speak, stop),
                pathLabel,
                FlowLayout.encloseCenterMiddle(rateLabel, rateValue, rateSlider),
                FlowLayout.encloseCenterMiddle(pitchLabel, pitchValue, pitchSlider)
                );
        f.show();
    }

    private void playWav(String filePath) throws IOException {
        if(filePath == null || filePath.trim().length() == 0) {
            throw new IOException("WAV file path is null/empty");
        }

        stopWav();

        String uri = filePath.trim();
        // CN1 media APIs are happiest with a URL. Normalize raw absolute paths to file:///...
        if (uri.startsWith("/")) {
            uri = "file://" + uri;  // -> file:///data/...
        } else if (uri.startsWith("file:/") && !uri.startsWith("file://")) {
            // Normalize file:/... (single slash) to file:///...
            uri = "file://" + uri.substring("file:".length());
        }

        // Use an InputStream-based media source to avoid Android's storage permission prompts
        // that can be triggered when MediaPlayer is fed a file:// URI.
        InputStream is;
        try {
            is = FileSystemStorage.getInstance().openInputStream(uri);
        } catch (IOException ex) {
            // Fallback: try with the native path (without the file: prefix).
            String nativePath;
            try {
                nativePath = FileSystemStorage.getInstance().toNativePath(uri);
            } catch (Throwable t) {
                nativePath = filePath.trim();
            }
            is = FileSystemStorage.getInstance().openInputStream(nativePath);
        }

        final InputStream finalIs = is;
        final Media m = MediaManager.createMedia(finalIs, "audio/wav");
        if (m == null) {
            try { finalIs.close(); } catch (IOException ignored) {}
            throw new IOException("MediaManager.createMedia(InputStream) returned null. uri=" + uri);
        }

        mediaStream = finalIs;
        media = m;

        MediaManager.addCompletionHandler(m, () -> {
            try {
                m.cleanup();
            } catch (Throwable ignored) {
            }
            try {
                finalIs.close();
            } catch (IOException ignored) {
            }
            if (media == m) {
                media = null;
            }
            if (mediaStream == finalIs) {
                mediaStream = null;
            }
        });

        m.play();
    }

    private void stopWav() {
        Media m = media;
        InputStream is = mediaStream;

        media = null;
        mediaStream = null;

        if (m != null) {
            try {
                m.pause();
            } catch (Throwable ignored) {
            }
            try {
                m.cleanup();
            } catch (Throwable ignored) {
            }
        }
        if (is != null) {
            try {
                is.close();
            } catch (IOException ignored) {
            }
        }
    }

    private static String simpleName(Throwable t) {
        if (t == null) {
            return "Error";
        }
        String n = t.getClass().getName();
        int p = n.lastIndexOf('.');
        return p >= 0 ? n.substring(p + 1) : n;
    }
    
    private static String formatOneDecimal(float value) {
        long scaled = (long) (value * 10.0f + (value >= 0.0f ? 0.5f : -0.5f));

        long intPart = scaled / 10;
        long fracPart = scaled % 10;
        if (fracPart < 0) fracPart = -fracPart;

        return String.valueOf(intPart) + "." + (char) ('0' + (int) fracPart);
    }


}
